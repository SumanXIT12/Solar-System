<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>solar </title>
  

</head>
<body>
<!-- partial:index.partial.html -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D Solar System</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #000;
    color: #fff;
    font-family: sans-serif;
  }
  canvas { display: block; }
  #controls {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.6);
    padding: 10px;
    border-radius: 10px;
    max-width: 200px;
    font-size: 12px;
    line-height: 1.2;
  }
  .planet-control { margin-bottom: 8px; }
  .planet-control input[type="range"] { width: 100%; }
  #controls button { margin-top: 8px; width: 100%; }
  #tooltip {
    position: absolute;
    background: rgba(0,0,0,0.7);
    color: #fff;
    padding: 5px 8px;
    font-size: 12px;
    border-radius: 4px;
    display: none;
    pointer-events: none;
    white-space: nowrap;
  }
</style>
</head>
<body>
<div id="controls"></div>
<div id="tooltip"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
let darkTheme = true;
let pause = false;

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
function setSystemView() {
  camera.position.set(0, 25, 80);
  camera.lookAt(0, 0, 0);
}
setSystemView();

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const clock = new THREE.Clock();

// Lighting
scene.add(new THREE.AmbientLight(0x555555));
const sunlight = new THREE.PointLight(0xffffff, 3, 0);
scene.add(sunlight);

// Starfield
const starsGeometry = new THREE.BufferGeometry();
const starVertices = [];
for (let i = 0; i < 10000; i++) {
  starVertices.push((Math.random() - 0.5) * 2000);
  starVertices.push((Math.random() - 0.5) * 2000);
  starVertices.push((Math.random() - 0.5) * 2000);
}
starsGeometry.setAttribute("position", new THREE.Float32BufferAttribute(starVertices, 3));
const starsMaterial = new THREE.PointsMaterial({ color: 0x888888 });
scene.add(new THREE.Points(starsGeometry, starsMaterial));

// Textures
const textureLoader = new THREE.TextureLoader();
textureLoader.setCrossOrigin("anonymous");

// Sun
const sunGeo = new THREE.SphereGeometry(5, 32, 32);
const sunMat = new THREE.MeshStandardMaterial({ emissive: 0xffff33, emissiveIntensity: 4, color: 0xffffff });
const sun = new THREE.Mesh(sunGeo, sunMat);
scene.add(sun);
sunlight.position.copy(sun.position);
textureLoader.load("https://threejs.org/examples/textures/sun.jpg",
  tex => { sunMat.map = tex; sunMat.needsUpdate = true; },
  undefined,
  () => console.warn("Sun texture failed, using fallback color.")
);

// Planets
const planetData = [
  { name: "Mercury", radius: 7,  size: 0.4, speed: 4.8, color: 0xb5b5b5, tex: "https://threejs.org/examples/textures/planets/mercury.jpg" },
  { name: "Venus",   radius: 10, size: 0.9, speed: 3.5, color: 0xe5c76b, tex: "https://threejs.org/examples/textures/planets/venus.jpg" },
  { name: "Earth",   radius: 13, size: 1.0, speed: 3.0, color: 0x2266ff, tex: "https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg" },
  { name: "Mars",    radius: 16, size: 0.6, speed: 2.4, color: 0xaa5533, tex: "https://threejs.org/examples/textures/planets/mars_1k_color.jpg" },
  { name: "Jupiter", radius: 21, size: 2.5, speed: 1.3, color: 0xd9a066, tex: "https://threejs.org/examples/textures/planets/jupiter.jpg" },
  { name: "Saturn",  radius: 26, size: 2.0, speed: 1.0, color: 0xdcc196, tex: "https://threejs.org/examples/textures/planets/saturn.jpg" },
  { name: "Uranus",  radius: 30, size: 1.5, speed: 0.8, color: 0x7fd4e3, tex: "https://threejs.org/examples/textures/planets/uranus.jpg" },
  { name: "Neptune", radius: 34, size: 1.5, speed: 0.7, color: 0x4c6bff, tex: "https://threejs.org/examples/textures/planets/neptune.jpg" }
];

const planetMeshes = [];
const speedMultiplier = {};
const controlsDiv = document.getElementById("controls");

planetData.forEach(d => {
  const mat = new THREE.MeshStandardMaterial({ color: d.color });
  const geo = new THREE.SphereGeometry(d.size, 32, 32);
  const mesh = new THREE.Mesh(geo, mat);
  scene.add(mesh);

  // Orbit line
  const orbit = new THREE.RingGeometry(d.radius - 0.05, d.radius + 0.05, 128);
  const orbitMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true, opacity: 0.3 });
  const orbitMesh = new THREE.Mesh(orbit, orbitMat);
  orbitMesh.rotation.x = Math.PI / 2;
  scene.add(orbitMesh);

  // Saturn Rings
  if (d.name === "Saturn") {
    const ringGeo = new THREE.RingGeometry(d.size * 1.2, d.size * 2, 64);
    const ringMat = new THREE.MeshStandardMaterial({
      map: textureLoader.load("https://threejs.org/examples/textures/planets/saturnringcolor.jpg"),
      side: THREE.DoubleSide,
      transparent: true
    });
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = Math.PI / 2;
    mesh.add(ring);
  }

  planetMeshes.push({ mesh, name: d.name, radius: d.radius, angle: Math.random() * Math.PI * 2, baseSpeed: d.speed });
  speedMultiplier[d.name] = 1;

  textureLoader.load(d.tex, tex => { mat.map = tex; mat.needsUpdate = true; });

  const ctrl = document.createElement("div");
  ctrl.className = "planet-control";
  ctrl.innerHTML = `<label>${d.name}</label><br>`;
  const slider = document.createElement("input");
  slider.type = "range";
  slider.min = "0";
  slider.max = "5";
  slider.step = "0.1";
  slider.value = "1";
  slider.addEventListener("input", e => { speedMultiplier[d.name] = parseFloat(e.target.value); });
  ctrl.appendChild(slider);
  controlsDiv.appendChild(ctrl);
});

// Buttons
const pauseBtn = document.createElement("button");
pauseBtn.textContent = "Pause";
pauseBtn.addEventListener("click", () => {
  pause = !pause;
  pauseBtn.textContent = pause ? "Resume" : "Pause";
});
controlsDiv.appendChild(pauseBtn);

const resetBtn = document.createElement("button");
resetBtn.textContent = "Reset Camera";
resetBtn.addEventListener("click", setSystemView);
controlsDiv.appendChild(resetBtn);

const themeBtn = document.createElement("button");
themeBtn.textContent = "Toggle Theme";
themeBtn.addEventListener("click", () => {
  darkTheme = !darkTheme;
  document.body.style.background = darkTheme ? "#000" : "#fff";
  document.body.style.color = darkTheme ? "#fff" : "#000";
});
controlsDiv.appendChild(themeBtn);

// Tooltip & picking
const tooltip = document.getElementById("tooltip");
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener("mousemove", e => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  tooltip.style.left = e.clientX + 10 + "px";
  tooltip.style.top = e.clientY + 10 + "px";
});

window.addEventListener("click", () => {
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(planetMeshes.map(p => p.mesh));
  if (intersects.length > 0) {
    const target = intersects[0].object.position;
    camera.position.set(target.x + 5, target.y + 5, target.z + 5);
    camera.lookAt(target);
  }
});

// Orbit speed scale
const ORBIT_SPEED_SCALE = 0.1;

// Animate
function animate() {
  requestAnimationFrame(animate);
  if (!pause) {
    const dt = clock.getDelta();
    planetMeshes.forEach(p => {
      const speed = p.baseSpeed * speedMultiplier[p.name] * ORBIT_SPEED_SCALE;
      p.angle += dt * speed;
      p.mesh.position.set(p.radius * Math.cos(p.angle), 0, p.radius * Math.sin(p.angle));
      p.mesh.rotation.y += dt * 1.5;
    });
    sun.rotation.y += dt * 0.5;
  }

  raycaster.setFromCamera(mouse, camera);
  const hit = raycaster.intersectObjects(planetMeshes.map(p => p.mesh));
  if (hit.length > 0) {
    const match = planetMeshes.find(p => p.mesh === hit[0].object);
    tooltip.textContent = match ? match.name : "";
    tooltip.style.display = "block";
  } else tooltip.style.display = "none";

  renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
<!-- partial -->
  
</body>
</html>
